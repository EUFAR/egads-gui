import logging


def option_information_text():
    logging.debug('gui - help_functions.py - option_information_text')
    info_dict = {'info_button_4': 'The user can change the verbose level of the logging system. '
                                  'If an issue is noticed, it is a good idea to change the level '
                                  'to DEBUG and send the log file to the developer.',
                 'info_button_5': 'The path and folder where to save the log file for the GUI, '
                                  'modifying this option assumes to restart the GUI',
                 'info_button_10': 'This option allows the GUI to check for an update online at '
                                  'startup automatically. The user has the possibility to check '
                                  'manually by clicking on the left button.',
                 'info_button_1': 'It is possible in EGADS to read the values of a variable '
                                  'stored in a NASA Ames/NetCDF file as floats. Selecting this '
                                  'option will ask EGADS to do so. Please read the documentation '
                                  'of EGADS to have more details.',
                 'info_button_2': 'By checking this option, EGADS will automatically replace '
                                  'missing values in data by Numpy NaN.',
                 'info_button_3': 'Numpy NaN is for float array only, thus it is not possible to '
                                  'replace missing values in variables composed of integer '
                                  'values. By checking this option, the user allows EGADS to '
                                  'switch back to the default option if the read of a variable '
                                  'fails in this particular situation.',
                 'info_button_6': 'The user can change the verbose level of the logging system. '
                                  'If an issue is noticed, it is a good idea to change the level '
                                  'to DEBUG and send the log file to the developer.',
                 'info_button_7': 'The path and folder where to save the log file for EGADS, '
                                  'modifying this option assumes to restart the GUI',
                 'info_button_11': 'This option allows the GUI to check EGADS update online at '
                                  'startup automatically. The user has the possibility to check '
                                  'manually by clicking on the left button.',
                 'info_button_8': 'When a user select more than one variables to plot them, '
                                   'based on this option, the GUI can ask him what to do, '
                                   'plot them on the same figure, or plot them on different '
                                   'subplots.',
                 'info_button_9': 'Based on this option, if multiple subplots are required, '
                                   'the GUI can organize the subplots automatically or let the '
                                   'user handle the layout himself.',
                 'info_button_12': 'When a user select for the first time, in each GUI running session, a standard '
                                   'variable to be plotted as the X axis, a popup will appear to inform him that it '
                                   'is intended to be used only with time series. This option can disable '
                                   'the popup permanently.',
                 'info_button_13': 'Enable the possibility to save a list of the different files opened by the user, '
                                   'in order to have a quick access to them. The list is accessible by clicking on '
                                   'File, then Open Recent.',
                 'info_button_14': 'This option gives the possibility to the user to register folders anywhere on the'
                                   ' hard drive and makes them accessible by clicking on File, then Quick Access.',
                 'info_button_15': 'By default, standard data are plotted according to there dimensions: the first '
                                   'dimension is considered as X axis, the second dimension as Y axis, and so on. '
                                   'With this option, the user can decide how the plot function will consider each '
                                   'dimension.',
                 'info_button_16': 'With this option, georeferenced gridded data are considered like standard data.',
                 'info_button_17': 'When deleting a dimension, if this option is checked, a warning message will '
                                   'be displayed.'
                 }
    return info_dict


def export_information_text():
    logging.debug('gui - help_functions.py - export_information_text')
    info_dict = {'info_button_1': 'The GUI gives to the user the possibility to export data into few external '
                                  'formats. At this time, it is possible to export data along a path ('
                                  'georeferenced time series generally) to Google Earth KML/KMZ file format. Please '
                                  'read the documentation for more details.',
                 'info_button_2': 'Data in Google Earth are georeferenced. Thus it is mandatory to provide longitude, '
                                  'latitude and (if possible) altitude to create a path. All data have to be vectors '
                                  'with the same amount of samples.',
                 'info_button_3': 'Choose here one or more variables to be displayed in Google Earth. The chosen '
                                  'variables are not strictly drawn and displayed. Only the path is displayed with '
                                  'a colormap and units for each variable.<br><br>Important note : at this time, '
                                  'only one variable is handled by the export function, due to the size of the output '
                                  'file. It will change in the next version.',
                 'info_button_4': 'The width of the path in pixel. Minimum is 1 px and maximum is 20 px.',
                 'info_button_5': 'By default, only a path is rendered. If checked, and if the path is not stuck to '
                                  'the ground, this option allow the GUI to connect the path to the ground with '
                                  'polygons.',
                 'info_button_6': 'If the above option is checked, by default, the polygons are filled with the same '
                                  'color chosen for the path. This option will add a certain amount of transparency '
                                  'to the polygons.',
                 'info_button_7': 'Sometime, a path can be composed of a great number of samples, in particular '
                                  'with airborne data, increasing greatly the size of the KML/KMZ file. Thus with this '
                                  'option, it is possible to reduce the number of samples by keeping 1 sample on N '
                                  'samples. Only integers are accepted.',
                 'info_button_8': 'A colormap is mandatory to display the values of a variable along a path in Google '
                                  'Earth. The different colormaps are from Matplotlib. Select one of them to activate '
                                  'all colormap options.',
                 'info_button_9': 'The colormap can be displayed at four different positions in Google Earth and '
                                  'following two orientations:<ul><li>horizontal and at the '
                                  'bottom</li><li>horizontal and at the top</li><li>vertical and on the '
                                  'left</li><li>vertical and on the right</li></ul>',
                 'info_button_11': 'This option is used to reverse the colormap. If the colormap is starting with blue '
                                  'and ending with red, the reversed colormap will start with red and and end with '
                                  'blue.',
                 'info_button_10': 'The path is a succession of segments. Each segment is composed of a starting '
                                   'point and a ending point, each of them defined by its coordinates and its value. '
                                   'In Google Earth, for a path, the points are not colored, but the segments are. '
                                   'This option is used to choose how each segment is colored:<ul><li>mean: the color '
                                   'of the segment is based on the value of the mean between the starting point and '
                                   'the ending point</li><li>first point: the color of the segment is based on the '
                                   'value of the starting point</li><li>last point: the color of the segment is based '
                                   'on the value of the ending point',
                 'info_button_12': 'If handled automaticallu, the minimum and maximum values of the colormap are the '
                                  'minimum (integer) and the maximum value (integer + 1) of the displayed variable. '
                                  'The number of steps is set to 15 and is the number of intervals equally distributed '
                                  'between the minimum and maximum values. Uncheck this option to handle those values '
                                  'manually.',
                 'info_button_13': 'If checked, the GUI handles the colormap dimensions automatically. Uncheck this '
                                   'option to set the dimensions according to your needs. By default, dimensions are '
                                   'set this way:<ul><li>for a vertical colormap:<ul><li>figure width = 1 ('
                                   'inches)</li><li>figure height = 8 (inches)</li><li>position from left = '
                                   '0.05 (fraction)</li><li>position from bottom = 0.05 (fraction)</li><li>colormap '
                                   'width = 0.25 (fraction)</li><li>colormap height = 0.9 ('
                                   'fraction)</li></ul></li></ul>'
                                   '<ul><li>for an horizontal colormap:<ul><li>figure width = 8 (inches)</li><li>figure'
                                   ' height = 1 (inches)</li><li>position from left = 0.05 (fraction)</li><li>position '
                                   'from bottom = 0.60 (fraction)</li><li>colormap width = 0.9 ('
                                   'fraction)</li><li>colormap height = 0.25 (fraction)</li></ul></li></ul>'}
    return info_dict


def batch_processing_information_text():
    logging.debug('gui - help.py - batch_processing_information_text')
    info_dict = {'bw_info_1': 'At this time, the batch processing function has 6 different '
                              'processes:<ul><li>the concatenation of multiple files</li><li>the '
                              'conversion of multiple NetCDF files to NASA Ames file '
                              'format</li><li>the conversion of multiple NASA Ames files to '
                              'NetCDF format</li><li>the deletion of one or more global metadata '
                              '(only for NetCDF files)</li><li>the deletion of one or more '
                              'variables</li><li>and the use of an algorithm on multiple '
                              'files</li></ul>Select one of them to display options related to '
                              'the selected process.',
                 'bw_proc_info_1': 'Once a category and an algorithm have been selected, the Algorithm '
                              'options tab will list the different input(s) and output(s).',
                 'bw_info_3': 'In case of error with one or more files, the GUI will decide to '
                              'continue or stop the processing based on this option.',
                 'bw_info_4': 'Select here all the files to be processed. It is possible to '
                              'select a specific format by playing the radiobuttons. If the GUI '
                              'detects files in the selected folder, those files are displayed '
                              'in the list below. Furthermore, it is possible to manipulate the '
                              'file list with the different buttons on the right of the file list.',
                 'bw_info_5': 'Select here the folder where to save files after the processing.',
                 'bw_info_6': 'If the previous option is selected, the GUI will handle the '
                              'filename automatically. However, if the user wants to manage '
                              'himself the name of all files after the processing, he can do it '
                              'by turning the option off. The creation of filenames is then '
                              'handles by the following widgets. In that case, the base filename '
                              'is the concatenation of the text displayed in each LineEdit below. '
                              'Each Combobox can be used to select pre-formated options or free '
                              'text.',
                 'Date and time': 'This option will display the actual date and time following '
                                  'the format:<ul><li><b>%Y</b> for year</li><li><b>%m</b> for '
                                  'month</li><li><b>%d</b> for day</li><li><b>%H</b> for '
                                  'hour</li><li><b>%M</b> for minute</li><li><b>%S</b> for '
                                  'second</li></ul>It is possible to mix text and options, '
                                  'or to write only date or time.<br><br><u>Ex:</u> '
                                  '<b>%Y-%m-%d-T%H:%M:%S</b> will display '
                                  '<b>2019-01-06T12:00:00</b>',
                 'Text': 'This option is used to write free text only.<br><br><u>Ex:</u> '
                         '<i>my_free_text</i>',
                 'Original filename': 'With this option, for each processed file, the new filename '
                                      'will contain the original filename. <br><br><u>Ex:</u> if '
                                      'the name of the processed file is '
                                      '<i>my_sea_level_measurements.nc</i>, the new filename will '
                                      'contain <i>my_sea_level_measurements</i>',
                 'Serial number with n digit': 'This option adds a number with n digit to the '
                                               'filename. As the processing iterates through the '
                                               'file list, the number increases by one at each '
                                               'iteration. It can be a number like <i>10</i> or a '
                                               'number preceded by one or more zeros like '
                                               '<i>0010</i>.<br><br><u>Ex:</u> 0010<br>&nbsp;&nbsp;'
                                               '&nbsp;&nbsp;sea_level_measurements_0010.nc<br>'
                                               '&nbsp;&nbsp;&nbsp;&nbsp;sea_level_measurements_'
                                               '0011.nc<br>&nbsp;&nbsp;&nbsp;&nbsp;sea_level_measu'
                                               'rements_0012.nc<br>&nbsp;&nbsp;&nbsp;&nbsp;...',
                 'Make a choice...': 'Please select an option first.',
                 'bw_info_7': 'bw_combobox_5',
                 'bw_info_8': 'bw_combobox_6',
                 'bw_info_9': 'bw_combobox_7',
                 'bw_info_10': 'bw_combobox_8',
                 'bw_info_11': 'bw_combobox_9'}

    return info_dict


def algorithm_creation_information_text():
    logging.debug('gui - help_functions.py - algorithm_creation_information_text')
    info_dict = {'cw_info_3': 'The name of the algorithm as implemented in EGADS. To aid in '
                              'algorithm usage and discovery, there is a general naming scheme '
                              'for egads algorithms. Generally, algorithm names are composed as '
                              'follows: {Measurement}{Context/Detail/Instrument}{'
                              'Source}<br><br><u>Ex</u>: AltitudePressureRaf',
                 'cw_info_4': 'The person who developed the algorithm.<br><br><u>Ex</u>: John '
                              'Doe',
                 'cw_info_5': 'The person, institution or entity who provided the algorithm.'
                              '<br><br><u>Ex</u>: NCAR - Earth Observing Laboratory',
                 'cw_info_6': 'Any references to literature, journals or documents with more '
                              'information on the current algorithm.<br><br><u>Ex</u>: A.C. van '
                              'der Kroonenberg et al, "Measuring the wind vector using the '
                              'autonomous mini aerial vehicle M^2AV", J. Atmos. Oceanic Technol., '
                              '25 (2008), pp. 1969-1982.',
                 'cw_info_7': 'The purpose of the algorithm.<br><br><u>Ex</u>: The '
                              'algorithm calculates static pressure',
                 'cw_info_8': 'A short description of what the algorithm does. <br><br><u>Ex</u>: '
                              'It calculates static pressure and dynamic pressure by correction of '
                              'static error. Angle of attack and sideslip are calculated from the'
                              ' horizontal and vertical differential pressures.',
                 'cw_info_9': 'General category of algorithm. The algorithm will be saved into '
                              'a folder with the name of the category.<br><br><u>Ex</u>: '
                              'Thermodynamics',
                 'cw_info_10': 'The algorithm itself. It has to be coded using Python 3. It is '
                               'still possible to import modules like numpy. Input and output '
                               'variables should be well defined, and the last line of the '
                               'algorithm has to return the output variable('
                               's).<br><br><u>Ex</u>:<br>&nbsp;&nbsp;&nbsp;&nbsp;a, b = 2, -6'
                               '<br>&nbsp;&nbsp;&nbsp;&nbsp;output_var = a * input_var + '
                               'b<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return output_var',
                 'cw_info_1': 'The purpose of this tab is to create input variable(s) used in the '
                              'previous algorithm field. Each variable required by the algorithm '
                              'should be created here.',
                 'cw_info_2': 'The purpose of this tab is to create output variable(s) used in the '
                              'previous algorithm field. Each variable returned by the algorithm '
                              'should be created here.',
                 'cw_info_bt_1': 'This is the input symbol. It has to correspond to the input '
                                 'symbol used in the previous algorithm field.<br><br><u>Ex</u>: '
                                 's_p',
                 'cw_info_bt_2': 'This is the unit of the input. There are 3 different ways to '
                                 'write the unit:<ol><li>by using text, ex: <b>m.s-1</b>, '
                                 'to inform EGADS that the unit of the input has to be '
                                 '<b>m.s-1</b></li><li>by using <b>None</b>, to inform EGADS that '
                                 'the input doesn\'t need a particular unit</li><li>by using a '
                                 'space, " ", to inform EGADS that the input has to be '
                                 'dimensionless.',
                 'cw_info_bt_3': 'This is the type of the input. The type can be an array ('
                                 'written <b>array</b>), a vector (written <b>vector</b>), '
                                 'or a coefficient (written <b>coeff</b>). If the input is '
                                 'optional, <b>_optional</b> should be added to the type.'
                                 '<br><br><u>Ex</u>: array or coeff_optional',
                 'cw_info_bt_4': 'A short description of the input.<br><br><u>Ex</u>: Particle '
                                 'counts in each bin over time',
                 'cw_info_bt_5': 'This is the output symbol. It has to correspond to the output '
                                 'symbol used in the previous algorithm field. '
                                 'It has to be return by the algorithm<br><br><u>Ex</u>: '
                                 'return out_altitude',
                 'cw_info_bt_6': 'This is the unit of the output. There are 2 different ways to '
                                 'write the unit:<ol><li>by using text, ex: <b>m.s-1</b>, '
                                 'to inform EGADS that the unit of the output has to be '
                                 '<b>m.s-1</b></li><li>by using <b>input<i>n</i></b> to inform '
                                 'EGADS that this output has to use the unit of the input <i>n</i>',
                 'cw_info_bt_7': 'This is the type of the input. The type can be an array ('
                                 'written <b>array</b>), a vector (written <b>vector</b>), '
                                 'or a coefficient (written <b>coeff</b>).<br><br><u>Ex</u>: '
                                 'array',
                 'cw_info_bt_8': 'This is the standard name of the output. There are 2 different '
                                 'ways to write the standard name:<ol><li>by using text, '
                                 'ex: pressure altitude </li><li>by using <b>input<i>n</i></b> '
                                 'with or without more text, this way egads knows that it has to '
                                 'take the standard name of the input <i>n</i>, ex: input0 '
                                 'corrected for something',
                 'cw_info_bt_9': 'This is the long name of the output. There are 2 different '
                                 'ways to write the long name:<ol><li>by using text, '
                                 'ex: pressure altitude computed from static pressure</li><li>by '
                                 'using <b>input<i>n</i></b> with or without more text, '
                                 'this way egads knows that it has to take the long name of the '
                                 'input <i>n</i>, ex: input0 corrected for something',
                 'cw_info_bt_10': 'A short description of the output.<br><br><u>Ex</u>: Mean '
                                  'diameter of the particles',
                 'cw_info_bt_11': 'Each output has to be linked to one or more categories.'}
    return info_dict


def plot_information_text():
    logging.debug('gui - help_functions.py - plot_information__text')
    info_dict = {'pw_info_bt_1': 'Control the size of the figure when it is saved, if the user wants a '
                                 'size different than the one of the window. Based on a ResizeEvent, the '
                                 'values are automatically updated when the figure is resized, even if the'
                                 'automatic option has been unlocked.',
                 'pw_info_bt_2': 'The resolution of the figure in dot per inch (dpi). Numbers up to 600 '
                                 'are accepted.',
                 'pw_info_bt_3': 'Use this checkbox to activate or deactivate the transparency of the '
                                 'background. 100 is the best possible quality, 1 is the worst.',
                 'pw_info_bt_4': 'This slider controls the quality of the picture if the JPEG format is '
                                 'selected when the picture is saved.',
                 'pw_figureOptions_bt_1': 'It is possible to customize the figure and axis titles, '
                                          'their fonts and the size of their fonts.',
                 'pw_figureOptions_bt_2': 'Ticks are controled from here. Please note that the numbers '
                                          'won\'t change if the user uses the pan and zoom functions.',
                 'pw_figureOptions_bt_6': 'A grid can be display and customized from here.',
                 'pw_figureOptions_bt_7': 'The legeng can move freely on the figure, this option '
                                          'allows the user to set it visible or not.',
                 'pw_commonOptions_bt_1': 'Figure margins are set by moving the sliders. The greater '
                                          'the number, the greater the margins. If multiple figures '
                                          'are displayed, the last sliders control the distance '
                                          'between those figures.',
                 'pw_plotOptions_bt_1': 'The line style is controled from here. The selection of the '
                                        'style impacts the way the line is customized below.',
                 'pw_plotOptions_bt_2': 'The color of the line can be changed to a predefined color, '
                                        'or a color defined by an RGB/HEX code.',
                 'pw_plotOptions_bt_3': 'This is the size of the line/marker.',
                 'pw_plotOptions_bt_4': 'This checkbox activates or deactivates the antialiasing '
                                        'function',
                 'pw_plotOptions_bt_5': 'This checkbox activates or deactivates the opacity and the '
                                        'value of opacity.',
                 'pw_plotOptions_bt_6': 'The name of the time series can be changed here.',
                 'pw_grid_info_button_1': 'Figure margins are set by moving the sliders. The greater the number, '
                                          'the greater the margins. Please remember that the proportions of each '
                                          'projection are fixed and can\'t be changed, whatever the margins.',
                 'pw_grid_info_button_2': 'It is possible to customize the figure and axis titles, their fonts, '
                                          'the size of their fonts, and their position.',
                 'pw_grid_info_button_3': 'The projection can be chosen from this list. Options for each projection '
                                          'are set by default and can be changed by clicking on Set options.',
                 'pw_grid_info_button_6': 'Click on Set X/Y ticks to change the ticks set by default. Please note '
                                          'that this option is not available for all projections.',
                 'pw_grid_info_button_11': 'Click on Set extent to change the extent of the map. If the '
                                           'projection has options to limit the extent, the limits set by the '
                                           'user can\'t excess the projection ones.<br>Extension values are based on'
                                           ' central longitude and central latitude (if they exists in the projection '
                                           'options): if the longitude extension is set between -45° and 45° with a '
                                           'central longitude of 45°E, the total extent is considered between 0°E and '
                                           '90°E.',
                 'pw_grid_info_button_7': 'This section controls the addition of coastlines, their resolution, their '
                                          'size and their color.',
                 'pw_grid_info_button_8': 'This section controls the addition of lakes and rivers, their resolution, '
                                          'their size and their color.',
                 'pw_grid_info_button_9': 'This section controls the addition of lands and their color.',
                 'pw_grid_info_button_10': 'This section controls the addition of oceans and their color.',
                 'pw_grid_info_button_4': 'With this option, it is possible to display or not a grid based on ticks. '
                                          'Following options control the appearance of the grid.',
                 'pw_grid_info_button_12': 'With this option, it is possible to display or not grid labels based on '
                                           'ticks.',
                 'pw_grid_info_button_5': 'This section control the aspect of the colorbar. Here is an explanation of '
                                          'the different options:<ul><li>Colormap legend: the legend is based on the '
                                          'units of the data, it can be modified by the user if '
                                          'necessary.</li><li>Colormap position: controls the position of the '
                                          'colorbar automatically.</li><li>Reverse colormap: it just reverse the '
                                          'color in the colorbar.</li><li>Handle colormap values automatically: if '
                                          'activated, the colormap values are set automatically by matplotlib and '
                                          'cartopy ; if not activated, the user can set colormap values by entering '
                                          'max and min values and a number of ticks, or by clicking on Set colorbar '
                                          'ticks to set the value of each tick and the number of ticks precisely.</li>'
                                          '<li>Handle colormap dimensions automatically: if activated, the dimensions '
                                          'of the colorbar are set automatically by matplotlib and cartopy ; if not '
                                          'activated, the user has to enter the dimensions and positions of the '
                                          'colorbar. Please remember that for horizontal position, 0 is considered '
                                          'are fully left and 1 as fully right. Same can apply for vertical position '
                                          'with 0 as bottom and 1 as top.</li></ul>',}
    return info_dict


def frozen_algorithm_formula_text():
    logging.debug('gui - help_functions.py - frozen_algorithm_formula_text')
    info_dict = {'microphysics - SampleAreaScatteringRaf': '        SA = DOF * BD\n        return SA\n\n',
                 'thermodynamics - altitude_pressure_incremental_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'microphysics - DiameterMedianVolumeDmt': '        rho_i = numpy.array(rho_i)\n        if len(rho_i) == 1:\n            rho_i = numpy.ones(len(d_i)) * rho_i\n        if s_i is 1.0:\n            s_i = numpy.ones(n_i.shape)\n        LWC_alg = egads.algorithms.microphysics.MassConcDmt(return_Egads=False)  # @UndefinedVariable\n        LWC_total = LWC_alg.run(n_i, d_i, s_i, rho_i)  # Assuming spherical, therefore shape factor is 1.\n        D_mvd = []\n        for j in range(len(n_i)):\n            LWC_i = []\n            i = 0\n            S_n = 0\n            while S_n < 0.5 * LWC_total[j] and i <= len(d_i):\n                LWC_i.append(LWC_alg.run(n_i[j, i], d_i[i], s_i[j, i], rho_i[i])[0])\n                S_n += LWC_i[i]\n                i = i + 1\n            i = i - 1\n            S_n1 = numpy.sum(LWC_i[:i])\n            D_mvd.append(d_i[i - 1] + (0.5 - S_n1 / S_n) * (d_i[i] - d_i[i - 1]))\n        return D_mvd\n\n',
                 'radiation - ScatteringAngles': '        sin = numpy.sin\n        cos = numpy.cos\n        rad2deg = 180 / numpy.pi\n        deg2rad = numpy.pi / 180.0\n        theta_sun_r = theta_sun * deg2rad\n        phi_sun_r = phi_sun * deg2rad\n        theta_c_r = theta_c * deg2rad\n        phi_c_r = phi_c * deg2rad\n        theta_scat_r = numpy.arccos(-sin(theta_sun_r) * cos(phi_sun_r) * sin(theta_c_r) * cos(phi_c_r)\n                                  - sin(theta_sun_r) * sin(phi_sun_r) * sin(theta_c_r) * cos(phi_c_r)\n                                  + cos(theta_sun_r) * cos(theta_c_r))\n        theta_scat = theta_scat_r * rad2deg\n        return theta_scat\n\n',
                 'microphysics - diameter_median_volume_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'microphysics - NumberConcTotalDmt': '        N = numpy.sum(c_i, axis=1)\n        return N\n\n',
                 'microphysics - number_conc_total_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'transforms - interpolation_linear': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'comparisons - CompareParamLcss': '        \n        # normalize S and R using standard deviation and mean if desired\n        if norm:\n            R = (R-numpy.mean(R))/numpy.std(R)\n            S = (S-numpy.mean(S))/numpy.std(S)\n        m = len(R)\n        n = len(S)\n        d = R.ndim\n\n        # Find range of data for each dimension to build correspondance grid G\n        if R.min(0) < S.min(0):\n            data_min = R.min(0)\n        else:\n            data_min = S.min(0)\n        if R.max(0) > S.max(0):\n            data_max = R.max(0)\n        else:\n            data_max = S.max(0)\n\n        # Define properties of correspondance grid G and initialize G\n        if d > 1:\n            G_shape = []\n            G_coords = []\n            for k in range(d + 1):\n                G_shape.append(int(math.floor(((data_max[k] + 3 * epsilon) - (data_min[k] - epsilon)))) / epsilon)\n                G_coords.append(numpy.arange(data_min[k] - epsilon, data_max[k] + 3 * epsilon, epsilon))\n            G = numpy.ndarray(tuple(G_shape), dtype=list)\n        else:\n            G_shape = int(math.floor(((data_max + 3 * epsilon) - (data_min - epsilon)) / epsilon))\n            G_coords = numpy.arange(data_min - epsilon, data_max + 3 * epsilon, epsilon)\n            G = numpy.ndarray(G_shape, dtype=list)\n        for item, _ in numpy.ndenumerate(G):\n            G[item] = []\n\n        # Populate G with lists of intersections from R (using R +/- epsilon in all dimensions)\n        for i in range(m):\n            if d > 1:\n                nearest_idx = []\n                nearest_idx_up = []\n                nearest_idx_down = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(R[i, k] - G_coords[:, k]).argmin())\n                    nearest_idx_up.append(numpy.abs(R[i, k] + epsilon - G_coords[:, k]).argmin())\n                    nearest_idx_down.append(numpy.abs(R[i, k] - epsilon - G_coords[:, k]).argmin())\n                for k in range(d):\n                    G[tuple(nearest_idx)].append(i)\n                    G[tuple(nearest_idx_up)].append(i)\n                    G[tuple(nearest_idx_down)].append(i)\n            else:\n                nearest_idx = numpy.abs(R[i] - G_coords[:]).argmin()\n                nearest_idx_up = numpy.abs(R[i] + epsilon - G_coords[:]).argmin()\n                nearest_idx_down = numpy.abs(R[i] - epsilon - G_coords[:]).argmin()\n                G[nearest_idx].append(i)\n                G[nearest_idx_up].append(i)\n                G[nearest_idx_down].append(i)\n        L = numpy.ndarray(n, dtype=list)\n        for item, _ in numpy.ndenumerate(L):\n            L[item] = []\n\n        # Determine matches between R and S using correspondence matrix G and store matches in\n        # L. All dimensions must match with maximum difference of epsilon in order to be stored\n        # in L.\n        for i in range(n):\n            if d > 1:\n                nearest_idx = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(S[i, k] - G_coords[:, k]).argmin())\n                for item in G[tuple(nearest_idx)]:\n                    all_flag = True\n                    for k in range(d):\n                        if abs(S[i, k] - R[item[k], k]) >= epsilon:\n                            all_flag = False\n                            break\n                    if all_flag is True:\n                        L[i].append(item[k])\n            else:\n                nearest_idx = numpy.abs(S[i] - G_coords[:]).argmin()\n                for item in G[nearest_idx]:\n                    all_flag = True\n                    if abs(S[i] - R[item]) >= epsilon:\n                        all_flag = False\n                        break\n                    if all_flag is True:\n                        L[i].append(item)\n        matches = numpy.zeros(n)\n        matches.fill(m)\n        matches[0] = 0\n        max_seq = 0\n\n        # Find longest sequence of matches between R and S using matching list L.\n        for j in range(n):\n            c = 0\n            temp = matches[0]\n            for k in L[j]:\n                if temp < k:\n                    while matches[c] < k:\n                        c += 1\n                    temp = matches[c]\n                    matches[c] = k\n                    if c > max_seq:\n                        max_seq = c\n        return max_seq\n',
                 'radiation - planck_emission': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - TempVirtualCnrm': '        RvRa = 1.608\n        T_v = T_s * (1 + RvRa * r) / (1 + r)\n        return T_v\n\n',
                 'corrections - logging': '        X_corr = deepcopy(X)\n        for i, X_i in enumerate(X):\n            i_up = i + 1\n            i_down = i - 1\n            if i_up < len(X) and i_down >= 0:\n                if (abs(X_i - X[i_down]) > S0 and abs(X_i - X[i_up]) > S0 and\n                        ((X_i - X[i_down]) * (X_i - X[i_up])) > 0):\n                    X_corr[i] = (X[i_up] + X[i_down]) / 2.0\n        return X_corr\n',
                 'thermodynamics - VelocityTasLongitudinalCnrm': '        V_tx = V_t / sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        return V_tx\n',
                 'microphysics - DiameterEffectiveDmt': '        sum_third_moment = numpy.sum(n_i * d_i ** 3, axis=1)\n        sum_second_moment = numpy.sum(n_i * d_i ** 2, axis=1)\n        D_e = (3. * sum_third_moment) / (4. * sum_second_moment)\n        return D_e\n\n',
                 'thermodynamics - PressureAngleIncidenceCnrm': '\n        errstat25 = (C_errstat[0] + C_errstat[1] * 25 + C_errstat[2] * 25 ** 2 + C_errstat[3] * 25 ** 3)\n        errstat = zeros(P_sr.shape)\n        errstat[delta_P_r > 25] = (C_errstat[0] + multiply(C_errstat[1], delta_P_r[delta_P_r > 25]) +\n                                    multiply(C_errstat[2], power(delta_P_r[delta_P_r > 25], 2)) +\n                                    multiply(C_errstat[3], power(delta_P_r[delta_P_r > 25], 3)))\n        errstat[logical_and(delta_P_r > 0, delta_P_r <= 25)] = (delta_P_r[logical_and(delta_P_r > 0, \n                                                                delta_P_r <= 25)] / 25) * errstat25\n        P_s = P_sr - errstat\n        delta_P = delta_P_r + errstat\n        alpha = C_alpha[0] + C_alpha[1] * (delta_P_v / delta_P)\n        beta = C_beta[0] + C_beta[1] * (delta_P_h / delta_P)\n        return P_s, delta_P, alpha, beta\n\n',
                 'thermodynamics - altitude_pressure_raf': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'transforms - convert_time_format': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'transforms - isotime_to_elements': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'thermodynamics - velocity_tas_longitudinal_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - DensityDryAirCnrm': '        R_a = 287.05 #J/kg/K\n        rho = (P_s * 100) / (R_a * T_s)\n        return rho\n\n',
                 'thermodynamics - velocity_tas_raf': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - density_dry_air_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - wind_vector_3d_raf': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - temp_potential_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'radiation - scattering_angles': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - pressure_angle_incidence_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'microphysics - ExtinctionCoeffDmt': '        B_e = numpy.pi / 4.0 * numpy.sum(Q_e * n_i * d_i ** 2, axis=1)\n        B_e = B_e * 0.001\n        return B_e\n\n',
                 'radiation - solar_vector_blanco': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - hum_rel_capacitive_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - VelocityMachRaf': '        gamma = 1.4\n        M = numpy.sqrt(2.0 / (gamma - 1.0) * ((dP / Ps + 1.0) ** ((gamma - 1) / gamma) - 1))\n        return M\n',
                 'microphysics - mass_conc_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'thermodynamics - pressure_dynamic_angle_incidence_vdk': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - PressureAngleIncidenceVdk': "\n        print('Warning: the algorithm is still in beta phase and must be reviewed.')\n\n        P_tot = (numpy.sqrt((1. / 125.) * ((delta_P_t + delta_P_r + delta_P_b + delta_P_l)**2\n                                      + (- 4 * delta_P_t + delta_P_r + delta_P_b + delta_P_l)**2\n                                      + (delta_P_t - 4 * delta_P_r + delta_P_b + delta_P_l)**2 \n                                      + (delta_P_t + delta_P_r - 4 * delta_P_b + delta_P_l)**2\n                                      + (delta_P_t + delta_P_r + delta_P_b - 4 * delta_P_l)**2)) \n                  + (1./4.) * (delta_P_t + delta_P_r + delta_P_b + delta_P_l)) \n        k_a = (delta_P_t - delta_P_b) / P_tot\n        k_b = (delta_P_r - delta_P_l) / P_tot\n\n        sum_out = numpy.zeros((12, len(k_a)))\n        for i in range(0, 12):\n            sum_in = numpy.zeros((12, len(k_b)))\n            for j in range(0, 12):\n                sum_in[j] = C_alpha[i][j] * (k_b ** j)\n            sum_out[i] = (k_a**i) * numpy.sum(sum_in, axis = 0)\n        alpha_cp = numpy.sum(sum_out, axis = 0)\n        \n        sum_out = numpy.zeros((12, len(k_a)))\n        for i in range(0,12):\n            sum_in = numpy.zeros((12, len(k_b)))\n            for j in range(0,12):\n                sum_in[j] = C_beta[i][j] * (k_b ** j)\n            sum_out[i] = (k_a**i) * numpy.sum(sum_in, axis = 0)\n        beta_cp = numpy.sum(sum_out, axis = 0)\n\n        sum_out = numpy.zeros((12, len(k_a)))\n        for i in range(0,12):\n            sum_in = numpy.zeros((12, len(k_b)))\n            for j in range(0,12):\n                sum_in[j] = C_dyn[i][j] * (k_b ** j)\n            sum_out[i] = (k_a**i) * numpy.sum(sum_in, axis = 0)\n        k_q = numpy.sum(sum_out, axis = 0)\n        \n        P_d = delta_P_s + P_tot * k_q\n        alpha = alpha_cp\n        beta = numpy.arctan(numpy.tan(beta_cp) / numpy.cos(alpha_cp))\n        \n        return P_d, alpha, beta\n\n",
                 'thermodynamics - logging': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'radiation - logging': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'mathematics - LimitAngleRange': '        angle_div = angle / 360.0\n        angle_fraction = abs(angle_div - numpy.int0(angle_div))\n        if angle.size == 1:\n            if angle >= 0:\n                angle_limited = 360 * angle_fraction\n            else:\n                angle_limited = 360 - 360 * angle_fraction\n        else:\n            angle_limited = numpy.zeros(angle.size)\n            angle_limited[angle >= 0] = 360 * angle_fraction[angle >= 0]\n            angle_limited[angle < 0] = 360 - 360 * angle_fraction[angle < 0]\n        return angle_limited\n\n',
                 'microphysics - diameter_effective_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'comparisons - logging': '        \n        # normalize S and R using standard deviation and mean if desired\n        if norm:\n            R = (R-numpy.mean(R))/numpy.std(R)\n            S = (S-numpy.mean(S))/numpy.std(S)\n        m = len(R)\n        n = len(S)\n        d = R.ndim\n\n        # Find range of data for each dimension to build correspondance grid G\n        if R.min(0) < S.min(0):\n            data_min = R.min(0)\n        else:\n            data_min = S.min(0)\n        if R.max(0) > S.max(0):\n            data_max = R.max(0)\n        else:\n            data_max = S.max(0)\n\n        # Define properties of correspondance grid G and initialize G\n        if d > 1:\n            G_shape = []\n            G_coords = []\n            for k in range(d + 1):\n                G_shape.append(int(math.floor(((data_max[k] + 3 * epsilon) - (data_min[k] - epsilon)))) / epsilon)\n                G_coords.append(numpy.arange(data_min[k] - epsilon, data_max[k] + 3 * epsilon, epsilon))\n            G = numpy.ndarray(tuple(G_shape), dtype=list)\n        else:\n            G_shape = int(math.floor(((data_max + 3 * epsilon) - (data_min - epsilon)) / epsilon))\n            G_coords = numpy.arange(data_min - epsilon, data_max + 3 * epsilon, epsilon)\n            G = numpy.ndarray(G_shape, dtype=list)\n        for item, _ in numpy.ndenumerate(G):\n            G[item] = []\n\n        # Populate G with lists of intersections from R (using R +/- epsilon in all dimensions)\n        for i in range(m):\n            if d > 1:\n                nearest_idx = []\n                nearest_idx_up = []\n                nearest_idx_down = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(R[i, k] - G_coords[:, k]).argmin())\n                    nearest_idx_up.append(numpy.abs(R[i, k] + epsilon - G_coords[:, k]).argmin())\n                    nearest_idx_down.append(numpy.abs(R[i, k] - epsilon - G_coords[:, k]).argmin())\n                for k in range(d):\n                    G[tuple(nearest_idx)].append(i)\n                    G[tuple(nearest_idx_up)].append(i)\n                    G[tuple(nearest_idx_down)].append(i)\n            else:\n                nearest_idx = numpy.abs(R[i] - G_coords[:]).argmin()\n                nearest_idx_up = numpy.abs(R[i] + epsilon - G_coords[:]).argmin()\n                nearest_idx_down = numpy.abs(R[i] - epsilon - G_coords[:]).argmin()\n                G[nearest_idx].append(i)\n                G[nearest_idx_up].append(i)\n                G[nearest_idx_down].append(i)\n        L = numpy.ndarray(n, dtype=list)\n        for item, _ in numpy.ndenumerate(L):\n            L[item] = []\n\n        # Determine matches between R and S using correspondence matrix G and store matches in\n        # L. All dimensions must match with maximum difference of epsilon in order to be stored\n        # in L.\n        for i in range(n):\n            if d > 1:\n                nearest_idx = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(S[i, k] - G_coords[:, k]).argmin())\n                for item in G[tuple(nearest_idx)]:\n                    all_flag = True\n                    for k in range(d):\n                        if abs(S[i, k] - R[item[k], k]) >= epsilon:\n                            all_flag = False\n                            break\n                    if all_flag is True:\n                        L[i].append(item[k])\n            else:\n                nearest_idx = numpy.abs(S[i] - G_coords[:]).argmin()\n                for item in G[nearest_idx]:\n                    all_flag = True\n                    if abs(S[i] - R[item]) >= epsilon:\n                        all_flag = False\n                        break\n                    if all_flag is True:\n                        L[i].append(item)\n        matches = numpy.zeros(n)\n        matches.fill(m)\n        matches[0] = 0\n        max_seq = 0\n\n        # Find longest sequence of matches between R and S using matching list L.\n        for j in range(n):\n            c = 0\n            temp = matches[0]\n            for k in L[j]:\n                if temp < k:\n                    while matches[c] < k:\n                        c += 1\n                    temp = matches[c]\n                    matches[c] = k\n                    if c > max_seq:\n                        max_seq = c\n        return max_seq\n',
                 'mathematics - limit_angle_range': '        angle_div = angle / 360.0\n        angle_fraction = abs(angle_div - numpy.int0(angle_div))\n        if angle.size == 1:\n            if angle >= 0:\n                angle_limited = 360 * angle_fraction\n            else:\n                angle_limited = 360 - 360 * angle_fraction\n        else:\n            angle_limited = numpy.zeros(angle.size)\n            angle_limited[angle >= 0] = 360 * angle_fraction[angle >= 0]\n            angle_limited[angle < 0] = 360 - 360 * angle_fraction[angle < 0]\n        return angle_limited\n\n',
                 'corrections - CorrectionSpikeSimpleCnrm': '        X_corr = deepcopy(X)\n        for i, X_i in enumerate(X):\n            i_up = i + 1\n            i_down = i - 1\n            if i_up < len(X) and i_down >= 0:\n                if (abs(X_i - X[i_down]) > S0 and abs(X_i - X[i_up]) > S0 and\n                        ((X_i - X[i_down]) * (X_i - X[i_up])) > 0):\n                    X_corr[i] = (X[i_up] + X[i_down]) / 2.0\n        return X_corr\n',
                 'thermodynamics - temp_static_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'mathematics - derivative_wrt_time': '        angle_div = angle / 360.0\n        angle_fraction = abs(angle_div - numpy.int0(angle_div))\n        if angle.size == 1:\n            if angle >= 0:\n                angle_limited = 360 * angle_fraction\n            else:\n                angle_limited = 360 - 360 * angle_fraction\n        else:\n            angle_limited = numpy.zeros(angle.size)\n            angle_limited[angle >= 0] = 360 * angle_fraction[angle >= 0]\n            angle_limited[angle < 0] = 360 - 360 * angle_fraction[angle < 0]\n        return angle_limited\n\n',
                 'radiation - temp_blackbody': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - temp_virtual_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'thermodynamics - HumRelCapacitiveCnrm': '        tempUcapf = numpy.array(Ucapf)\n        tempUcapf[tempUcapf < Fmin] = Fmin\n        Ucapf = tempUcapf.tolist()\n        temp_factor = 273.15 + 20\n        H_u = (P_s / (P_s + dP)) * (C_0 + numpy.multiply(C_1, Ucapf) + \n            numpy.multiply(C_2, numpy.power(Ucapf, 2)) + numpy.multiply(C_t, (T_s - temp_factor)))\n        return H_u\n    \n',
                 'microphysics - DiameterMeanRaf': '        D_bar = numpy.sum(n_i * d_i, axis=1) / numpy.sum(n_i, axis=1)\n        return D_bar\n',
                 'microphysics - diameter_mean_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'transforms - IsotimeToSeconds': '        time_delta_secs = []\n        SECS_PER_DAY = 60 * 60 * 24\n        if fmt:\n            fmt = convert_time_format(fmt)\n            if t_ISO_ref:\n                time0 = datetime.datetime.strptime(str(t_ISO_ref), fmt)\n            else:\n                time0 = self.default_ref_time\n            for time in t_ISO:\n                time_decomp = datetime.datetime.strptime(time, fmt)\n                time_delta = time_decomp - time0\n                time_delta_secs.append(time_delta.days * SECS_PER_DAY + time_delta.seconds +\n                                       time_delta.microseconds * 1.0e-6)\n        else:\n            if t_ISO_ref:\n                time0 = dateutil.parser.parse(str(t_ISO_ref))\n            else:\n                time0 = self.default_ref_time\n            for time in t_ISO:\n                time_decomp = dateutil.parser.parse(time)\n                time_delta = time_decomp - time0\n                time_delta_secs.append(time_delta.days * SECS_PER_DAY + time_delta.seconds +\n                                       time_delta.microseconds * 1.0e-6)\n        return time_delta_secs\n\n',
                 'radiation - PlanckEmission': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = 2 * h * c ** 2 / (l ** 5 * (numpy.exp(h * c / (kb * l * T)) - 1.0)) * 1e-9\n        return rad\n\n',
                 'mathematics - logging': '        angle_div = angle / 360.0\n        angle_fraction = abs(angle_div - numpy.int0(angle_div))\n        if angle.size == 1:\n            if angle >= 0:\n                angle_limited = 360 * angle_fraction\n            else:\n                angle_limited = 360 - 360 * angle_fraction\n        else:\n            angle_limited = numpy.zeros(angle.size)\n            angle_limited[angle >= 0] = 360 * angle_fraction[angle >= 0]\n            angle_limited[angle < 0] = 360 - 360 * angle_fraction[angle < 0]\n        return angle_limited\n\n',
                 'transforms - SecondsToIsotime': '        if fmt:\n            fmt = str(fmt)\n        else:\n            fmt = self.format_default\n        fmt = convert_time_format(fmt)\n        t_ISO = []\n        if t_ref:\n            datetime_ref = dateutil.parser.parse(str(t_ref))\n        else:\n            datetime_ref = dateutil.parser.parse(str(self.default_ref_time)) \n        for time in t_secs:\n            time_delta = datetime.timedelta(0, float(time))\n            merge_time = datetime_ref + time_delta\n            tmp = merge_time.strftime(fmt)\n            t_ISO.append(tmp)\n        return t_ISO\n',
                 'microphysics - SampleAreaOapCenterInRaf': '        SA = numpy.array([])\n        Lambda_mm = Lambda * 1e-6  # convert wavelength to mm\n        dD_mm = dD * 1e-3  # convert diameter to mm\n        ESW = N * dD_mm / M\n        for i in range(int(N)):\n            X = i + 1\n            R = X * dD_mm / 2.0\n            DOF = 6 * R ** 2 / (Lambda_mm)\n            if DOF > D_arms:\n                DOF = D_arms\n            SA = numpy.append(SA, DOF * ESW * 1e-6)  # convert mm2 to m2\n        return SA\n',
                 'microphysics - surface_area_conc_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'thermodynamics - AltitudePressureIncrementalCnrm': '        R_a = 287.0531\n        g = 9.80665\n        R_ag = R_a / g\n        nb_val = P_s.size\n        alt_p = numpy.zeros(nb_val)\n        if not S0:\n            S0 = t[0]\n        index_S0 = numpy.where(t > S0)[0][0] - 1\n        alt_p[index_S0] = Z0\n        before_S0 = list(reversed(range(index_S0)))\n        after_S0 = range(index_S0 + 1, nb_val, 1)\n        \n        for i in before_S0:\n            alt_p[i] = alt_p[i + 1] + R_ag * ((T_v[i] + T_v[i + 1])/2.)*numpy.log(P_s[i + 1]/P_s[i])\n        for i in after_S0:\n            alt_p[i] = alt_p[i - 1] + R_ag * ((T_v[i] + T_v[i - 1])/2.)*numpy.log(P_s[i - 1]/P_s[i])\n        \n        return alt_p\n',
                 'microphysics - logging': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'microphysics - SampleAreaOapAllInRaf': '        SA = numpy.array([])\n        Lambda_mm = Lambda * 1e-6  # convert wavelength to mm\n        dD_mm = dD * 1e-3  # convert diameter to mm\n        for i in range(int(N)):\n            X = i + 1\n            R = X * dD_mm / 2.0\n            DOF = 6 * R ** 2 / (Lambda_mm)\n            if DOF > D_arms:\n                DOF = D_arms\n            ESW = dD_mm * (N - X - 1) / M\n            SA = numpy.append(SA, DOF * ESW * 1e-6)  # convert mm2 to m2\n        return SA\n',
                 'radiation - camera_viewing_angles': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'transforms - InterpolationLinear': '        if not f_left:\n            f_left = f[0]\n        if not f_right:\n            f_right = f[-1]\n        f_interp = []\n        index = np.argwhere(~np.isnan(f))\n        f = f[index]\n        x = x[index]\n        for x_val in x_interp:\n            if x_val < x[0]:\n                f_interp.append(f_left)\n            elif x_val > x[-1]:\n                f_interp.append(f_right)\n            else:\n                index = np.where(x == x_val)[0]\n                if not index:\n                    try:\n                        lower_x = x[x < x_val][-1]\n                    except IndexError:\n                        lower_x = x_val\n                    try:\n                        lower_f = f[x < x_val][-1]\n                    except IndexError:\n                        lower_f = f[0][0]\n                    try:\n                        upper_x = x[x > x_val][0]\n                    except IndexError:\n                        upper_x = x_val\n                    try:\n                        upper_f = f[x > x_val][0]\n                    except IndexError:\n                        upper_f = f[-1][0]\n                    f_interp.append(lower_f + (x_val - lower_x) * (upper_f - lower_f) / (upper_x - lower_x))\n                else:\n                    f_interp.append(f[index[0]])\n        return f_interp\n\n',
                 'radiation - solar_vector_reda': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - TempStaticCnrm': '        T_s = Tt / (1 + r_f * ((1 + dP / P_s) ** Racpa - 1))\n        return T_s\n\n',
                 'transforms - time_to_decimal_year': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'microphysics - NumberConcTotalRaf': '        N_t = numpy.sum(n_i / SV, axis=1)\n        return N_t\n\n',
                 'microphysics - SurfaceAreaConcDmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'radiation - RotateSolarVectorToAircraftFrame': "        cos = numpy.cos\n        sin = numpy.sin\n        deg2rad = numpy.pi / 180.0\n        rad2deg = 180.0 / numpy.pi\n        phi_sun = 360 - phi_sun\n        yaw = 360 - yaw\n        theta_sun_r = theta_sun * deg2rad\n        phi_sun_r = phi_sun * deg2rad\n        roll_r = roll * deg2rad\n        pitch_r = pitch * deg2rad\n        yaw_r = yaw * deg2rad\n        x = sin(theta_sun_r) * cos(phi_sun_r)\n        y = sin(theta_sun_r) * sin(phi_sun_r)\n        z = cos(theta_sun_r)\n        xx = x * (cos(pitch_r) * cos(yaw_r)) + y * (cos(pitch_r) * sin(yaw_r)) + z * (-sin(pitch_r))\n        yy = (x * (sin(roll_r) * sin(pitch_r) * cos(yaw_r) - cos(roll_r) * sin(yaw_r))\n              + y * (sin(roll_r) * sin(pitch_r) * sin(yaw_r) + cos(roll_r) * cos(yaw_r))\n              + z * (sin(roll_r) * cos(pitch_r)))\n        zz = (x * (cos(roll_r) * sin(pitch_r) * cos(yaw_r) + sin(roll_r) * sin(yaw_r))\n              + y * (cos(roll_r) * sin(pitch_r) * sin(yaw_r) - sin(roll_r) * cos(yaw_r))\n              + z * (cos(roll_r) * cos(pitch_r)))\n        theta_new = numpy.arccos(zz / numpy.sqrt(xx ** 2 + yy ** 2 + zz ** 2)) * rad2deg\n        phi_new = egads.EgadsData(value=360, units='deg', long_name='') - egads.algorithms.mathematics.LimitAngleRange().run(numpy.arctan(yy / xx) * rad2deg)  # @UndefinedVariable\n        return theta_new, phi_new\n\n",
                 'radiation - SolarVectorBlanco': "        year = numpy.array([], 'i')\n        month = numpy.array([], 'i')\n        day = numpy.array([], 'i')\n        hour = numpy.array([])\n        idx = numpy.array([], 'i')\n        for element in date_time.flat:\n            date_time_sep = dateparser.parse(str(element))\n            year = numpy.append(year, date_time_sep.year)\n            month = numpy.append(month, date_time_sep.month)\n            day = numpy.append(day, date_time_sep.day)\n            if (date_time_sep.month <= 2):\n                idx = numpy.append(idx, -1)\n            else:\n                idx = numpy.append(idx, 0)\n            hour = numpy.append(hour,\n                                date_time_sep.hour +\n                                date_time_sep.minute / 60.0 +\n                                date_time_sep.second / 3600.0)\n        EARTH_MEAN_RADIUS = 6371.01  # km\n        AU = 149597890.0  # km\n\n        # Calculate Julian Day\n        jd = ((1461 * (year + 4800 + idx)) / 4 +\n              (367 * (month - 2 - 12 * idx)) / 12 -\n              (3 * ((year + 4900 + idx) / 100)) / 4 +\n              day - 32075)\n\n        n = jd - 0.5 + hour / 24.0 - 2451545.0\n\n        # Calculate ecliptic coordinates of the sun\n        Omega = 2.1429 - 0.0010394594 * n\n        L = 4.8950630 + 0.017202791698 * n\n        g = 6.2400600 + 0.0172019699 * n\n        l = (L + 0.03341607 * numpy.sin(g) + 0.00034894 * numpy.sin(2 * g) -\n             0.0001134 - 0.0000203 * numpy.sin(Omega))\n        ep = 0.4090928 - 6.2140e-9 * n + 0.0000396 * numpy.cos(Omega)\n\n        # Convert ecliptic coordinates to celestial coordinates\n        ra = numpy.arctan2(numpy.cos(ep) * numpy.sin(l), numpy.cos(l))\n        delta = numpy.arcsin(numpy.sin(ep) * numpy.sin(l))\n        ra = ra % (2 * numpy.pi)  # @UndefinedVariable\n\n        # Convert from celestial coordinates to horizontal coordinates\n        gmst = 6.6974243242 + 0.0657098283 * n + hour\n        lmst = (gmst * 15 + lon) * numpy.pi / 180.0\n        hour_angle = lmst - ra\n        theta_z = numpy.arccos(numpy.cos(lat * numpy.pi / 180.0) *\n                               numpy.cos(hour_angle) * numpy.cos(delta) +\n                               numpy.sin(delta) * numpy.sin(lat * numpy.pi / 180.0))\n        gamma = numpy.arctan2(-numpy.sin(hour_angle), (numpy.tan(delta) *\n                                                       numpy.cos(lat * numpy.pi / 180) -\n                                                       numpy.sin(lat * numpy.pi / 180) *\n                                                       numpy.cos(hour_angle))\n                              )\n        Parallax = EARTH_MEAN_RADIUS / AU * numpy.sin(theta_z)\n        theta_z = theta_z + Parallax\n        return [ra, delta, theta_z, gamma]\n\n",
                 'transforms - IsotimeToElements': '        year = []\n        month = []\n        day = []\n        hour = []\n        minute = []\n        second = []\n        for time in date_time:\n            time_tuple = dateutil.parser.parse(time)\n            year.append(time_tuple.year)\n            month.append(time_tuple.month)\n            day.append(time_tuple.day)\n            hour.append(time_tuple.hour)\n            minute.append(time_tuple.minute)\n            second.append(time_tuple.second)\n        return year, month, day, hour, minute, second\n\n',
                 'thermodynamics - WindVector3dRaf': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'microphysics - number_conc_total_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'radiation - CameraViewingAngles': '        AngleLimit = egads.algorithms.mathematics.LimitAngleRange  # @UndefinedVariable\n        theta_c = numpy.zeros([n_x, n_y])\n        phi_c = numpy.zeros([n_x, n_y])\n        for i in range(n_x):\n            x = (i - n_x / 2.) / n_x * l_x\n            for j in range(n_y):\n                y = (j - n_y / 2.) / n_y * l_y\n                d = numpy.sqrt(x ** 2 + y ** 2)\n                theta_c[i, j] = AngleLimit().run(2 * numpy.arctan(d / (2. * f)) * 180.0 / numpy.pi)\n                phi_c[i, j] = AngleLimit().run(360 - numpy.arctan2(y, x) * 180.0 / numpy.pi)\n        return theta_c, phi_c\n\n',
                 'transforms - isotime_to_seconds': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'thermodynamics - VelocityTasCnrm': '        V_p = numpy.sqrt(2 * cpa * T_s * ((1 + dP / P_s) ** Racpa - 1))\n        return V_p\n\n',
                 'radiation - TempBlackbody': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'thermodynamics - AltitudePressureRaf': '        P_0 = 1013.25  # hPa\n        T_0 = 288.15  # K\n        R_a = 287.0531  # J/kg/K\n        g = 9.80665  # m/s2\n        L = 0.0065  # K/m\n        P_1 = 226.3206  # hPa\n        T_1 = 216.65  # K\n        H_1 = 11000.0  # m\n        if P_s.size == 1:\n            if P_s >= P_1:\n                H = (T_0 / L) * (1 - (P_s / P_0) ** (R_a * L / g))\n            else:\n                H = H_1 + ((R_a * T_1) / g) * numpy.log(P_1 / P_s)\n        else:\n            H = numpy.zeros(P_s.size)\n            H[P_s >= P_1] = (T_0 / L) * (1 - (P_s[P_s >= P_1] / P_0) ** (R_a * L / g))\n            H[P_s < P_1] = H_1 + ((R_a * T_1) / g) * numpy.log(P_1 / P_s[P_s < P_1])\n        return H\n',
                 'radiation - SolarVectorReda': '        RAD_TO_DEG = 180 / numpy.pi\n        DEG_TO_RAD = numpy.pi / 180.0\n\n        # A, B, C terms of L0\n        L0 = numpy.array([[175347046.0, 0, 0],\n                          [3341656.0, 4.6692568, 6283.07585],\n                          [34894.0, 4.6261, 12566.1517],\n                          [3497.0, 2.7441, 5753.3849],\n                          [3418.0, 2.8289, 3.5231],\n                          [3136.0, 3.6277, 77713.7715],\n                          [2676.0, 4.4181, 7860.4194],\n                          [2343.0, 6.1352, 3930.2097],\n                          [1324.0, 0.7425, 11506.7698],\n                          [1273.0, 2.0371, 529.691],\n                          [1199.0, 1.1096, 1577.3435],\n                          [990, 5.233, 5884.927],\n                          [902, 2.045, 26.298],\n                          [857, 3.508, 398.149],\n                          [780, 1.179, 5223.694],\n                          [753, 2.533, 5507.553],\n                          [505, 4.583, 18849.228],\n                          [492, 4.205, 775.523],\n                          [357, 2.92, 0.067],\n                          [317, 5.849, 11790.629],\n                          [284, 1.899, 796.298],\n                          [271, 0.315, 10977.079],\n                          [243, 0.345, 5486.778],\n                          [206, 4.806, 2544.314],\n                          [205, 1.869, 5573.143],\n                          [202, 2.458, 6069.777],\n                          [156, 0.833, 213.299],\n                          [132, 3.411, 2942.463],\n                          [126, 1.083, 20.775],\n                          [115, 0.645, 0.98],\n                          [103, 0.636, 4694.003],\n                          [102, 0.976, 15720.839],\n                          [102, 4.267, 7.114],\n                          [99, 6.21, 2146.17],\n                          [98, 0.68, 155.42],\n                          [86, 5.98, 161000.69],\n                          [85, 1.3, 6275.96],\n                          [85, 3.67, 71430.7],\n                          [80, 1.81, 17260.15],\n                          [79, 3.04, 12036.46],\n                          [75, 1.76, 5088.63],\n                          [74, 3.5, 3154.69],\n                          [74, 4.68, 801.82],\n                          [70, 0.83, 9437.76],\n                          [62, 3.98, 8827.39],\n                          [61, 1.82, 7084.9],\n                          [57, 2.78, 6286.6],\n                          [56, 4.39, 14143.5],\n                          [56, 3.47, 6279.55],\n                          [52, 0.19, 12139.55],\n                          [52, 1.33, 1748.02],\n                          [51, 0.28, 5856.48],\n                          [49, 0.49, 1194.45],\n                          [41, 5.37, 8429.24],\n                          [41, 2.4, 19651.05],\n                          [39, 6.17, 10447.39],\n                          [37, 6.04, 10213.29],\n                          [37, 2.57, 1059.38],\n                          [36, 1.71, 2352.87],\n                          [36, 1.78, 6812.77],\n                          [33, 0.59, 17789.85],\n                          [30, 0.44, 83996.85],\n                          [30, 2.74, 1349.87],\n                          [25, 3.16, 4690.48]])\n\n        L1 = numpy.array([[628331966747.0, 0, 0],\n                          [206059.0, 2.678235, 6283.07585],\n                          [4303.0, 2.6351, 12566.1517],\n                          [425.0, 1.59, 3.523],\n                          [119.0, 5.796, 26.298],\n                          [109.0, 2.966, 1577.344],\n                          [93, 2.59, 18849.23],\n                          [72, 1.14, 529.69],\n                          [68, 1.87, 398.15],\n                          [67, 4.41, 5507.55],\n                          [59, 2.89, 5223.69],\n                          [56, 2.17, 155.42],\n                          [45, 0.4, 796.3],\n                          [36, 0.47, 775.52],\n                          [29, 2.65, 7.11],\n                          [21, 5.34, 0.98],\n                          [19, 1.85, 5486.78],\n                          [19, 4.97, 213.3],\n                          [17, 2.99, 6275.96],\n                          [16, 0.03, 2544.31],\n                          [16, 1.43, 2146.17],\n                          [15, 1.21, 10977.08],\n                          [12, 2.83, 1748.02],\n                          [12, 3.26, 5088.63],\n                          [12, 5.27, 1194.45],\n                          [12, 2.08, 4694],\n                          [11, 0.77, 553.57],\n                          [10, 1.3, 6286.6],\n                          [10, 4.24, 1349.87],\n                          [9, 2.7, 242.73],\n                          [9, 5.64, 951.72],\n                          [8, 5.3, 2352.87],\n                          [6, 2.65, 9437.76],\n                          [6, 4.67, 4690.48]])\n\n        L2 = numpy.array([[52919.0, 0, 0],\n                          [8720.0, 1.0721, 6283.0758],\n                          [309.0, 0.867, 12566.152],\n                          [27, 0.05, 3.52],\n                          [16, 5.19, 26.3],\n                          [16, 3.68, 155.42],\n                          [10, 0.76, 18849.23],\n                          [9, 2.06, 77713.77],\n                          [7, 0.83, 775.52],\n                          [5, 4.66, 1577.34],\n                          [4, 1.03, 7.11],\n                          [4, 3.44, 5573.14],\n                          [3, 5.14, 796.3],\n                          [3, 6.05, 5507.55],\n                          [3, 1.19, 242.73],\n                          [3, 6.12, 529.69],\n                          [3, 0.31, 398.15],\n                          [3, 2.28, 553.57],\n                          [2, 4.38, 5223.69],\n                          [2, 3.75, 0.98]\n                          ])\n\n        L3 = numpy.array([[289.0, 5.844, 6283.076],\n                          [35, 0, 0],\n                          [17, 5.49, 12566.15],\n                          [3, 5.2, 155.42],\n                          [1, 4.72, 3.52],\n                          [1, 5.3, 18849.23],\n                          [1, 5.97, 242.73]\n                          ])\n\n        L4 = numpy.array([[114.0, 3.142, 0],\n                          [8, 4.13, 6283.08],\n                          [1, 3.84, 12566.15]\n                          ])\n\n        L5 = numpy.array([[1, 3.14, 0]])\n\n        B0 = numpy.array([[280.0, 3.199, 84334.662],\n                          [102.0, 5.422, 5507.553],\n                          [80, 3.88, 5223.69],\n                          [44, 3.7, 2352.87],\n                          [32, 4, 1577.34]\n                          ])\n\n        B1 = numpy.array([[9, 3.9, 5507.55],\n                          [6, 1.73, 5223.69]\n                          ])\n\n        R0 = numpy.array([[100013989.0, 0, 0],\n                          [1670700.0, 3.0984635, 6283.07585],\n                          [13956.0, 3.05525, 12566.1517],\n                          [3084.0, 5.1985, 77713.7715],\n                          [1628.0, 1.1739, 5753.3849],\n                          [1576.0, 2.8469, 7860.4194],\n                          [925.0, 5.453, 11506.77],\n                          [542.0, 4.564, 3930.21],\n                          [472.0, 3.661, 5884.927],\n                          [346.0, 0.964, 5507.553],\n                          [329.0, 5.9, 5223.694],\n                          [307.0, 0.299, 5573.143],\n                          [243.0, 4.273, 11790.629],\n                          [212.0, 5.847, 1577.344],\n                          [186.0, 5.022, 10977.079],\n                          [175.0, 3.012, 18849.228],\n                          [110.0, 5.055, 5486.778],\n                          [98, 0.89, 6069.78],\n                          [86, 5.69, 15720.84],\n                          [86, 1.27, 161000.69],\n                          [65, 0.27, 17260.15],\n                          [63, 0.92, 529.69],\n                          [57, 2.01, 86996.85],\n                          [56, 5.24, 71430.7],\n                          [49, 3.25, 2544.31],\n                          [47, 2.58, 775.52],\n                          [45, 5.54, 9437.76],\n                          [43, 6.01, 6275.96],\n                          [39, 5.36, 4694],\n                          [38, 2.39, 8827.39],\n                          [37, 0.83, 19651.05],\n                          [37, 4.9, 12139.55],\n                          [36, 1.67, 12036.46],\n                          [35, 1.84, 2942.46],\n                          [33, 0.24, 7084.9],\n                          [32, 0.18, 5088.63],\n                          [32, 1.78, 398.15],\n                          [28, 1.21, 6286.6],\n                          [28, 1.9, 6279.55],\n                          [26, 4.59, 10447.39]\n                          ])\n\n        R1 = numpy.array([[103019.0, 1.10749, 6283.07585],\n                          [1721.0, 1.0644, 12566.1517],\n                          [702.0, 3.142, 0],\n                          [32, 1.02, 18849.23],\n                          [31, 2.84, 55073.55],\n                          [25, 1.32, 5223.69],\n                          [18, 1.42, 1577.34],\n                          [10, 5.91, 10977.08],\n                          [9, 1.42, 6275.96],\n                          [9, 0.27, 5486.78]\n                          ])\n\n        R2 = numpy.array([[4359.0, 5.7846, 6283.0758],\n                          [124.0, 5.579, 12566.152],\n                          [12, 3.14, 0],\n                          [9, 3.63, 77713.77],\n                          [6, 1.87, 5573.14],\n                          [3, 5.47, 18849.23]\n                          ])\n\n        R3 = numpy.array([[145.0, 4.273, 6283.076],\n                          [7, 3.92, 12566.15]\n                          ])\n\n        R4 = numpy.array([[4, 2.56, 6283.08]])\n\n        Y = numpy.array([[0, 0, 0, 0, 1],\n                         [-2, 0, 0, 2, 2],\n                         [0, 0, 0, 2, 2],\n                         [0, 0, 0, 0, 2],\n                         [0, 1, 0, 0, 0],\n                         [0, 0, 1, 0, 0],\n                         [-2, 1, 0, 2, 2],\n                         [0, 0, 0, 2, 1],\n                         [0, 0, 1, 2, 2],\n                         [-2, -1, 0, 2, 2],\n                         [-2, 0, 1, 0, 0],\n                         [-2, 0, 0, 2, 1],\n                         [0, 0, -1, 2, 2],\n                         [2, 0, 0, 0, 0],\n                         [0, 0, 1, 0, 1],\n                         [2, 0, -1, 2, 2],\n                         [0, 0, -1, 0, 1],\n                         [0, 0, 1, 2, 1],\n                         [-2, 0, 2, 0, 0],\n                         [0, 0, -2, 2, 1],\n                         [2, 0, 0, 2, 2],\n                         [0, 0, 2, 2, 2],\n                         [0, 0, 2, 0, 0],\n                         [-2, 0, 1, 2, 2],\n                         [0, 0, 0, 2, 0],\n                         [-2, 0, 0, 2, 0],\n                         [0, 0, -1, 2, 1],\n                         [0, 2, 0, 0, 0],\n                         [2, 0, -1, 0, 1],\n                         [-2, 2, 0, 2, 2],\n                         [0, 1, 0, 0, 1],\n                         [-2, 0, 1, 0, 1],\n                         [0, -1, 0, 0, 1],\n                         [0, 0, 2, -2, 0],\n                         [2, 0, -1, 2, 1],\n                         [2, 0, 1, 2, 2],\n                         [0, 1, 0, 2, 2],\n                         [-2, 1, 1, 0, 0],\n                         [0, -1, 0, 2, 2],\n                         [2, 0, 0, 2, 1],\n                         [2, 0, 1, 0, 0],\n                         [-2, 0, 2, 2, 2],\n                         [-2, 0, 1, 2, 1],\n                         [2, 0, -2, 0, 1],\n                         [2, 0, 0, 0, 1],\n                         [0, -1, 1, 0, 0],\n                         [-2, -1, 0, 2, 1],\n                         [-2, 0, 0, 0, 1],\n                         [0, 0, 2, 2, 1],\n                         [-2, 0, 2, 0, 1],\n                         [-2, 1, 0, 2, 1],\n                         [0, 0, 1, -2, 0],\n                         [-1, 0, 1, 0, 0],\n                         [-2, 1, 0, 0, 0],\n                         [1, 0, 0, 0, 0],\n                         [0, 0, 1, 2, 0],\n                         [0, 0, -2, 2, 2],\n                         [-1, -1, 1, 0, 0],\n                         [0, 1, 1, 0, 0],\n                         [0, -1, 1, 2, 2],\n                         [2, -1, -1, 2, 2],\n                         [0, 0, 3, 2, 2],\n                         [2, -1, 0, 2, 2]\n                         ])\n\n        delta_psi_coeff = numpy.array([[-171996, -174.2],\n                                       [-13187, -1.6],\n                                       [-2274, -0.2],\n                                       [2062, 0.2],\n                                       [1426, -3.4],\n                                       [712, 0.1],\n                                       [-517, 1.2],\n                                       [-386, -0.4],\n                                       [-301, 0.0],\n                                       [217, -0.5],\n                                       [-158, 0.0],\n                                       [129, 0.1],\n                                       [123, 0.0],\n                                       [63, 0.0],\n                                       [63, 0.1],\n                                       [-59, 0.0],\n                                       [-58, -0.1],\n                                       [-51, 0.0],\n                                       [48, 0.0],\n                                       [46, 0.0],\n                                       [-38, 0.0],\n                                       [-31, 0.0],\n                                       [29, 0.0],\n                                       [29, 0.0],\n                                       [26, 0.0],\n                                       [-22, 0.0],\n                                       [21, 0.0],\n                                       [17, -0.1],\n                                       [16, 0.0],\n                                       [-16, 0.1],\n                                       [-15, 0.0],\n                                       [-13, 0.0],\n                                       [-12, 0.0],\n                                       [11, 0.0],\n                                       [-10, 0.0],\n                                       [-8, 0.0],\n                                       [7, 0.0],\n                                       [-7, 0.0],\n                                       [-7, 0.0],\n                                       [-7, 0.0],\n                                       [6, 0.0],\n                                       [6, 0.0],\n                                       [6, 0.0],\n                                       [-6, 0.0],\n                                       [-6, 0.0],\n                                       [5, 0.0],\n                                       [-5, 0.0],\n                                       [-5, 0.0],\n                                       [-5, 0.0],\n                                       [4, 0.0],\n                                       [4, 0.0],\n                                       [4, 0.0],\n                                       [-4, 0.0],\n                                       [-4, 0.0],\n                                       [-4, 0.0],\n                                       [3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0],\n                                       [-3, 0.0]\n                                       ])\n\n        delta_epsilon_coeff = numpy.array([[92025, 8.9],\n                                           [5736, -3.1],\n                                           [977, -0.5],\n                                           [-895, 0.5],\n                                           [54, -0.1],\n                                           [-7, 0.0],\n                                           [224, -0.6],\n                                           [200, 0.0],\n                                           [129, -0.1],\n                                           [-95, 0.3],\n                                           [0.0, 0.0],\n                                           [-70, 0.0],\n                                           [-53, 0.0],\n                                           [0.0, 0.0],\n                                           [-33, 0.0],\n                                           [26, 0.0],\n                                           [32, 0.0],\n                                           [27, 0.0],\n                                           [0.0, 0.0],\n                                           [-24, 0.0],\n                                           [16, 0.0],\n                                           [13, 0.0],\n                                           [0.0, 0.0],\n                                           [-12, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [-10, 0.0],\n                                           [0.0, 0.0],\n                                           [-8, 0.0],\n                                           [7, 0.0],\n                                           [9, 0.0],\n                                           [7, 0.0],\n                                           [6, 0.0],\n                                           [0.0, 0.0],\n                                           [5, 0.0],\n                                           [3, 0.0],\n                                           [-3, 0.0],\n                                           [0.0, 0.0],\n                                           [3, 0.0],\n                                           [3, 0.0],\n                                           [0.0, 0.0],\n                                           [-3, 0.0],\n                                           [-3, 0.0],\n                                           [3, 0.0],\n                                           [3, 0.0],\n                                           [0.0, 0.0],\n                                           [3, 0.0],\n                                           [3, 0.0],\n                                           [3, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0],\n                                           [0.0, 0.0]\n                                           ])\n\n        year = numpy.array([], \'i\')\n        month = numpy.array([], \'i\')\n        day = numpy.array([])\n        for element in date_time.flat:\n            date_time_sep = dateparser.parse(str(element))\n            year = numpy.append(year, date_time_sep.year)\n            month = numpy.append(month, date_time_sep.month)\n            frac_day = (date_time_sep.hour / 24.0 +\n                        date_time_sep.minute / (24 * 60.0) +\n                        date_time_sep.second / (24 * 60.0 * 60.0))\n            day = numpy.append(day, date_time_sep.day + frac_day)\n        for i, _ in enumerate(year):\n            if month[i] <= 2:\n                year[i] -= 1\n                month[i] += 12\n        A = numpy.int0(year / 100)\n        B = 2 - A + numpy.int0(A / 4)\n\n        # Calcluate Julian Day, Ephemeris Day, Century and Millenium\n        JD = numpy.int0(365.25 * (year + 4716)) + numpy.int0(30.6001 * (month + 1)) + day - 1524.5\n        if isinstance(B, numpy.int64):\n            JD[JD > 2299160.0] += B\n        else:\n            JD[JD > 2299160.0] += B[JD > 2299160.0]\n        JDE = JD + self.__compute_delta_T(year) / 86400.0\n        JC = (JD - 2451545) / 36525.0\n        JCE = (JDE - 2451545) / 36525.0\n        JME = JCE / 10.0\n\n        # Calculate the Earth heliocentric longitude, latitude and radius vector\n        L0a = numpy.tile(L0, (len(JME), 1, 1))\n        L1a = numpy.tile(L1, (len(JME), 1, 1))\n        L2a = numpy.tile(L2, (len(JME), 1, 1))\n        L3a = numpy.tile(L3, (len(JME), 1, 1))\n        L4a = numpy.tile(L4, (len(JME), 1, 1))\n        L5a = numpy.tile(L5, (len(JME), 1, 1))\n        L0i = L0a[:, :, 0].T * numpy.cos(L0a[:, :, 1].T + numpy.outer(L0[:, 2], JME))\n        L1i = L1a[:, :, 0].T * numpy.cos(L1a[:, :, 1].T + numpy.outer(L1[:, 2], JME))\n        L2i = L2a[:, :, 0].T * numpy.cos(L2a[:, :, 1].T + numpy.outer(L2[:, 2], JME))\n        L3i = L3a[:, :, 0].T * numpy.cos(L3a[:, :, 1].T + numpy.outer(L3[:, 2], JME))\n        L4i = L4a[:, :, 0].T * numpy.cos(L4a[:, :, 1].T + numpy.outer(L4[:, 2], JME))\n        L5i = L5a[:, :, 0].T * numpy.cos(L5a[:, :, 1].T + numpy.outer(L5[:, 2], JME))\n        L0_sum = L0i.sum(axis=0)\n        L1_sum = L1i.sum(axis=0)\n        L2_sum = L2i.sum(axis=0)\n        L3_sum = L3i.sum(axis=0)\n        L4_sum = L4i.sum(axis=0)\n        L5_sum = L5i.sum(axis=0)\n        L = (L0_sum + L1_sum * JME + L2_sum * JME ** 2 + L3_sum * JME ** 3 +\n             L4_sum * JME ** 4 + L5_sum * JME ** 5) / (1.0e8) * RAD_TO_DEG\n        B1a = numpy.tile(B1, (len(JME), 1, 1))\n        B0a = numpy.tile(B0, (len(JME), 1, 1))\n        B0i = B0a[:, :, 0].T * numpy.cos(B0a[:, :, 1].T + numpy.outer(B0[:, 2], JME))\n        B1i = B1a[:, :, 0].T * numpy.cos(B1a[:, :, 1].T + numpy.outer(B1[:, 2], JME))\n        B0_sum = B0i.sum(axis=0)\n        B1_sum = B1i.sum(axis=0)\n        B = (B0_sum + B1_sum * JME) / (1.0e8) * RAD_TO_DEG\n        R0a = numpy.tile(R0, (len(JME), 1, 1))\n        R1a = numpy.tile(R1, (len(JME), 1, 1))\n        R2a = numpy.tile(R2, (len(JME), 1, 1))\n        R3a = numpy.tile(R3, (len(JME), 1, 1))\n        R4a = numpy.tile(R4, (len(JME), 1, 1))\n        R0i = R0a[:, :, 0].T * numpy.cos(R0a[:, :, 1].T + numpy.outer(R0[:, 2], JME))\n        R1i = R1a[:, :, 0].T * numpy.cos(R1a[:, :, 1].T + numpy.outer(R1[:, 2], JME))\n        R2i = R2a[:, :, 0].T * numpy.cos(R2a[:, :, 1].T + numpy.outer(R2[:, 2], JME))\n        R3i = R3a[:, :, 0].T * numpy.cos(R3a[:, :, 1].T + numpy.outer(R3[:, 2], JME))\n        R4i = R4a[:, :, 0].T * numpy.cos(R4a[:, :, 1].T + numpy.outer(R4[:, 2], JME))\n        R0_sum = R0i.sum(axis=0)\n        R1_sum = R1i.sum(axis=0)\n        R2_sum = R2i.sum(axis=0)\n        R3_sum = R3i.sum(axis=0)\n        R4_sum = R4i.sum(axis=0)\n        R = (R0_sum + R1_sum * JME + R2_sum * JME ** 2 + R3_sum * JME ** 3 +\n             R4_sum * JME ** 4) / (1.0e8)\n             \n        # Calculate the geocentric longitude and latitude\n        Theta = egads.algorithms.mathematics.LimitAngleRange().run(L + 180).value\n        beta = -B\n\n        # Calculate the nutation in longitude and obliquity\n        X = numpy.zeros([len(JCE), 5])\n        X[:, 0] = 297.85036 + 445267.111480 * JCE - 0.0019142 * JCE ** 2 + JCE ** 3 / 189474.0\n        X[:, 1] = 357.52772 + 35999.050340 * JCE - 0.0001603 * JCE ** 2 + JCE ** 3 / 300000.0\n        X[:, 2] = 134.96298 + 477198.867398 * JCE + 0.0086972 * JCE ** 2 + JCE ** 3 / 56250.0\n        X[:, 3] = 93.27191 + 483202.017538 * JCE + 0.0036825 * JCE ** 2 + JCE ** 3 / 327270.0\n        X[:, 4] = 125.04452 - 1934.136261 * JCE + 0.0020708 * JCE ** 2 + JCE ** 3 / 450000.0\n        delta_psi_coeff_ext = numpy.tile(delta_psi_coeff, (len(JCE), 1, 1))\n        delta_epsilon_coeff_ext = numpy.tile(delta_epsilon_coeff, (len(JCE), 1, 1))\n        X_Y_sum = numpy.dot(X, Y.T) * DEG_TO_RAD\n        delta_psi_i = (delta_psi_coeff_ext[:, :, 0].T +\n                       numpy.outer(delta_psi_coeff[:, 1], JCE)) * numpy.sin(X_Y_sum.T)\n        delta_epsilon_i = (delta_epsilon_coeff_ext[:, :, 0].T +\n                           numpy.outer(delta_epsilon_coeff[:, 1], JCE)) * numpy.cos(X_Y_sum.T)\n        delta_psi = delta_psi_i.sum(axis=0) / 36000000.0\n        delta_epsilon = delta_epsilon_i.sum(axis=0) / 36000000.0\n        \n        # Calculate the true obliquity of the ecliptic\n        U = JME / 10.0\n        epsilon_0 = (84381.448 - 4680.93 * U - 1.55 * U ** 2 + 1999.25 * U ** 3 -\n                     51.38 * U ** 4 - 249.67 * U ** 5 - 39.05 * U ** 6 + 7.12 * U ** 7 +\n                     27.87 * U ** 8 + 5.79 * U ** 9 + 2.45 * U ** 10)\n        epsilon = epsilon_0 / 3600.0 + delta_epsilon\n\n        # Calculate the aberration correction\n        delta_tau = -20.4898 / (3600.0 * R)\n\n        # Calculate the apparent sun longitude\n        lambda_sun = Theta + delta_psi + delta_tau\n\n        # Calculate apparent sidereal time at Greenwich\n        nu_0 = (280.46061837 + 360.98564736629 * (JD - 2451545) + 0.000387933 * JC ** 2 - JC ** 3 / 38710000.0)\n        nu_0 = egads.algorithms.mathematics.LimitAngleRange().run(nu_0).value\n        nu = nu_0 + delta_psi * numpy.cos(epsilon * DEG_TO_RAD)\n\n        # Calculate geocentric sun right ascension\n        alpha = numpy.arctan2(numpy.sin(lambda_sun * DEG_TO_RAD) * numpy.cos(epsilon * DEG_TO_RAD) -\n                              numpy.tan(beta * DEG_TO_RAD) * numpy.sin(epsilon * DEG_TO_RAD),\n                              numpy.cos(lambda_sun * DEG_TO_RAD)) * RAD_TO_DEG\n        alpha = egads.algorithms.mathematics.LimitAngleRange().run(alpha).value\n\n        # Calculate geocentric sun declination\n        delta = numpy.arcsin(numpy.sin(beta * DEG_TO_RAD) * numpy.cos(epsilon * DEG_TO_RAD) +\n                             numpy.cos(beta * DEG_TO_RAD) * numpy.sin(epsilon * DEG_TO_RAD) *\n                             numpy.sin(lambda_sun * DEG_TO_RAD)) * RAD_TO_DEG\n\n        # Calculate the observer local hour angle\n        H = nu + lon - alpha\n        H = egads.algorithms.mathematics.LimitAngleRange().run(H).value\n\n        # Calculate the topocentric sun right ascension\n        xi = 8.794 / (3600.0 * R)\n        u = numpy.arctan(0.99664719 * numpy.tan(lat * DEG_TO_RAD))\n        x = numpy.cos(u) + elevation / 6378140.0 * numpy.cos(lat * DEG_TO_RAD)\n        y = 0.99664719 * numpy.sin(u) + elevation / 6378140.0 * numpy.sin(lat * DEG_TO_RAD)\n        delta_alpha = numpy.arctan2(-x * numpy.sin(xi * DEG_TO_RAD) * numpy.sin(H * DEG_TO_RAD),\n                                    numpy.cos(delta * DEG_TO_RAD) - x * numpy.sin(xi * DEG_TO_RAD) *\n                                    numpy.cos(H * DEG_TO_RAD)) * RAD_TO_DEG\n        delta_prime = numpy.arctan2((numpy.sin(delta * DEG_TO_RAD) - y * numpy.sin(xi * DEG_TO_RAD)) *\n                                     numpy.cos(delta_alpha * DEG_TO_RAD),\n                                     numpy.cos(delta * DEG_TO_RAD) -\n                                     x * numpy.sin(xi * DEG_TO_RAD) * numpy.cos(H * DEG_TO_RAD)) * RAD_TO_DEG\n\n        # Calculate topocentric hour angle\n        H_prime = H - delta_alpha\n\n        # Calculate the topographic zenith angle\n        e_0 = numpy.arcsin(numpy.sin(lat * DEG_TO_RAD) * numpy.sin(delta_prime * DEG_TO_RAD) +\n                           numpy.cos(lat * DEG_TO_RAD) * numpy.cos(delta_prime * DEG_TO_RAD) *\n                           numpy.cos(H_prime * DEG_TO_RAD)) * RAD_TO_DEG\n        if pressure.any() and temperature.any():\n            tan_arg = e_0 + 10.3 / (e_0 + 5.11)\n            delta_e = pressure / 1010.0 * 283 / (273.0 + temperature) * 1.02 / (60 *\n                                                                              numpy.tan(tan_arg * DEG_TO_RAD))\n        else:\n            delta_e = 0\n        e = e_0 + delta_e\n        theta = 90 - e\n\n        # Calculate the topocentric azimuth angle\n        Gamma = numpy.arctan2(numpy.sin(H_prime * DEG_TO_RAD),\n                              numpy.cos(H_prime * DEG_TO_RAD) * numpy.sin(lat * DEG_TO_RAD) -\n                              numpy.tan(delta_prime * DEG_TO_RAD) * numpy.cos(lat * DEG_TO_RAD)) * RAD_TO_DEG\n        Gamma = egads.algorithms.mathematics.LimitAngleRange().run(Gamma).value\n        Phi = Gamma + 180\n        Phi = egads.algorithms.mathematics.LimitAngleRange().run(Phi).value\n        return [theta, Phi]\n    \n    def __compute_delta_T(self, year):\n        """\n        Compute delta_T, the difference between Earth rotation time and the Terrestrial time, based\n        on NASA GSFC "Polynomial expressions for delta T" (cf. https://eclipse.gsfc.nasa.gov/LEcat5/deltatpoly.html)\n        """\n        \n        delta_T = 67. # default value used by Matt Freer at algorithm creation time\n        \n        if year < -500:\n            t = (year - 1820.) / 100.\n            delta_T = -20. + 32. * t ** 2.\n        elif year >= -500 and year < 500:\n            t = year / 100.\n            delta_T = 10583.6 - 1014.41 * t + 33.78311 * t ** 2 - 5.952053 * t ** 3 \n            - 0.1798452 * t ** 4 + 0.022174192 * t ** 5 + 0.0090316521 * t ** 6 \n        elif year >= 500 and year < 1600:\n            t = (year - 1000.) / 100.\n            delta_T = 1574.2 - 556.01 * t + 71.23472 * t ** 2 + 0.319781 * t ** 3 - 0.8503463 * t ** 4 \n            - 0.005050998 * t ** 5 + 0.0083572073 * t ** 6\n        elif year >= 1600 and year < 1700:\n            t = year - 1600.\n            delta_T = 120 - 0.9808 * t - 0.01532 * t ** 2 + (t ** 3) / 7129. \n        elif year >= 1700 and year < 1800:\n            t = year - 1700.\n            delta_T = 8.83 + 0.1603 * t - 0.0059285 * t ** 2 + 0.00013336 * t ** 3 - (t ** 4) / 1174000.\n        elif year >= 1800 and year < 1860:\n            t = year - 1800.\n            delta_T = 13.72 - 0.332447 * t + 0.0068612 * t ** 2 + 0.0041116 * t ** 3 - 0.00037436 * t ** 4 \n            + 0.0000121272 * t ** 5 - 0.0000001699 * t ** 6 + 0.000000000875 * t ** 7\n        elif year >= 1860 and year < 1900:\n            t = year - 1860.\n            delta_T = 7.62 + 0.5737 * t - 0.251754 * t ** 2 + 0.01680668 * t ** 3 -0.0004473624 * t ** 4 \n            + (t ** 5) / 233174.\n        elif year >= 1900 and year < 1920:\n            t = year - 1900.\n            delta_T = -2.79 + 1.494119 * t - 0.0598939 * t ** 2 + 0.0061966 * t ** 3 - 0.000197 * t ** 4 \n        elif year >= 1920 and year < 1941:\n            t = year - 1920.\n            delta_T = 21.20 + 0.84493 * t - 0.076100 * t ** 2 + 0.0020936 * t ** 3\n        elif year >= 1941 and year < 1960:\n            t = year - 1950.\n            delta_T = 29.07 + 0.407 * t - (t ** 2) / 233. + (t ** 3) / 2547.\n        elif year >= 1961 and year < 1986:\n            t = year - 1975.\n            delta_T = 45.45 + 1.067 * t - t ** 2 / 260. - t ** 3 / 718.\n        elif year >= 1986 and year < 2005:\n            t = year - 2000.\n            delta_T = 63.86 + 0.3345 * t - 0.060374 * t ** 2 + 0.0017275 * t ** 3 + 0.000651814 * t ** 4 \n            + 0.00002373599 * t ** 5\n        elif year >= 2005 and year < 2050:\n            t = year - 2000.\n            delta_T = 62.92 + 0.32217 * t + 0.005589 * t ** 2\n        elif year >= 2050 and year < 2150:\n            delta_T = -20. + 32. * ((year - 1820.) / 100.) ** 2 - 0.5628 * (2150. - year)\n        elif year >= 2150:\n            t = (year - 1820.) / 100.\n            delta_T = -20. + 32. * t ** 2\n  \n        return delta_T\n        \n',
                 'microphysics - sample_area_oap_all_in_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'microphysics - sample_volume_general_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'comparisons - compare_param_lcss': '        \n        # normalize S and R using standard deviation and mean if desired\n        if norm:\n            R = (R-numpy.mean(R))/numpy.std(R)\n            S = (S-numpy.mean(S))/numpy.std(S)\n        m = len(R)\n        n = len(S)\n        d = R.ndim\n\n        # Find range of data for each dimension to build correspondance grid G\n        if R.min(0) < S.min(0):\n            data_min = R.min(0)\n        else:\n            data_min = S.min(0)\n        if R.max(0) > S.max(0):\n            data_max = R.max(0)\n        else:\n            data_max = S.max(0)\n\n        # Define properties of correspondance grid G and initialize G\n        if d > 1:\n            G_shape = []\n            G_coords = []\n            for k in range(d + 1):\n                G_shape.append(int(math.floor(((data_max[k] + 3 * epsilon) - (data_min[k] - epsilon)))) / epsilon)\n                G_coords.append(numpy.arange(data_min[k] - epsilon, data_max[k] + 3 * epsilon, epsilon))\n            G = numpy.ndarray(tuple(G_shape), dtype=list)\n        else:\n            G_shape = int(math.floor(((data_max + 3 * epsilon) - (data_min - epsilon)) / epsilon))\n            G_coords = numpy.arange(data_min - epsilon, data_max + 3 * epsilon, epsilon)\n            G = numpy.ndarray(G_shape, dtype=list)\n        for item, _ in numpy.ndenumerate(G):\n            G[item] = []\n\n        # Populate G with lists of intersections from R (using R +/- epsilon in all dimensions)\n        for i in range(m):\n            if d > 1:\n                nearest_idx = []\n                nearest_idx_up = []\n                nearest_idx_down = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(R[i, k] - G_coords[:, k]).argmin())\n                    nearest_idx_up.append(numpy.abs(R[i, k] + epsilon - G_coords[:, k]).argmin())\n                    nearest_idx_down.append(numpy.abs(R[i, k] - epsilon - G_coords[:, k]).argmin())\n                for k in range(d):\n                    G[tuple(nearest_idx)].append(i)\n                    G[tuple(nearest_idx_up)].append(i)\n                    G[tuple(nearest_idx_down)].append(i)\n            else:\n                nearest_idx = numpy.abs(R[i] - G_coords[:]).argmin()\n                nearest_idx_up = numpy.abs(R[i] + epsilon - G_coords[:]).argmin()\n                nearest_idx_down = numpy.abs(R[i] - epsilon - G_coords[:]).argmin()\n                G[nearest_idx].append(i)\n                G[nearest_idx_up].append(i)\n                G[nearest_idx_down].append(i)\n        L = numpy.ndarray(n, dtype=list)\n        for item, _ in numpy.ndenumerate(L):\n            L[item] = []\n\n        # Determine matches between R and S using correspondence matrix G and store matches in\n        # L. All dimensions must match with maximum difference of epsilon in order to be stored\n        # in L.\n        for i in range(n):\n            if d > 1:\n                nearest_idx = []\n                for k in range(d):\n                    nearest_idx.append(numpy.abs(S[i, k] - G_coords[:, k]).argmin())\n                for item in G[tuple(nearest_idx)]:\n                    all_flag = True\n                    for k in range(d):\n                        if abs(S[i, k] - R[item[k], k]) >= epsilon:\n                            all_flag = False\n                            break\n                    if all_flag is True:\n                        L[i].append(item[k])\n            else:\n                nearest_idx = numpy.abs(S[i] - G_coords[:]).argmin()\n                for item in G[nearest_idx]:\n                    all_flag = True\n                    if abs(S[i] - R[item]) >= epsilon:\n                        all_flag = False\n                        break\n                    if all_flag is True:\n                        L[i].append(item)\n        matches = numpy.zeros(n)\n        matches.fill(m)\n        matches[0] = 0\n        max_seq = 0\n\n        # Find longest sequence of matches between R and S using matching list L.\n        for j in range(n):\n            c = 0\n            temp = matches[0]\n            for k in L[j]:\n                if temp < k:\n                    while matches[c] < k:\n                        c += 1\n                    temp = matches[c]\n                    matches[c] = k\n                    if c > max_seq:\n                        max_seq = c\n        return max_seq\n',
                 'corrections - correction_spike_simple_cnrm': '        X_corr = deepcopy(X)\n        for i, X_i in enumerate(X):\n            i_up = i + 1\n            i_down = i - 1\n            if i_up < len(X) and i_down >= 0:\n                if (abs(X_i - X[i_down]) > S0 and abs(X_i - X[i_up]) > S0 and\n                        ((X_i - X[i_down]) * (X_i - X[i_up])) > 0):\n                    X_corr[i] = (X[i_up] + X[i_down]) / 2.0\n        return X_corr\n',
                 'thermodynamics - velocity_mach_raf': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'mathematics - DerivativeWrtTime': '        x_dot = []\n        for i, _ in enumerate(x):\n            i_up = i + 1\n            i_down = i - 1\n            if i_down < 0:\n                i_down = 0\n            if i_up >= len(x):\n                i_up = len(x) - 1\n            x_dot.append((x[i_up] - x[i_down]) / (t[i_up] - t[i_down]))\n        return x_dot\n\n',
                 'thermodynamics - TempPotentialCnrm': '        theta = T_s * (1000.0 / P_s) ** Racpa\n        return theta\n\n',
                 'transforms - seconds_to_isotime': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'thermodynamics - VelocityTasRaf': '        R = 287.04 # J/kg/K\n        gamma = 1.4\n        V_t = sqrt((R * gamma * T_r * (M ** 2)) / (1.0 + 0.5 * (gamma - 1) * e * (M ** 2)))\n        return V_t\n\n',
                 'microphysics - sample_area_scattering_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'transforms - TimeToDecimalYear': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'microphysics - sample_area_oap_center_in_raf': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'thermodynamics - velocity_tas_cnrm': '        D = sqrt(1 + tan(alpha) ** 2 + tan(beta) ** 2)\n        u = ((-U_a / D) * (sin(psi) * cos(theta) + tan(beta) * (cos(psi) * cos(phi) \n                         + sin(psi) * sin(theta) * sin(phi)) + tan(alpha) * (sin(psi) * sin(theta) * cos(phi) \n                         - cos(psi) * sin(phi))) + u_p - L * (theta_dot * sin(theta) * sin(psi) - psi_dot * cos(psi) * cos(theta)))\n        v = ((-U_a / D) * (cos(psi) * cos(theta) -\n                         tan(beta) * (sin(psi) * cos(phi) - cos(psi) * sin(theta) * sin(phi)) +\n                         tan(alpha) * (cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi))) +\n             v_p - L * (psi_dot * sin(psi) * cos(theta) + theta_dot * cos(psi) * sin(theta)))\n        w = ((-U_a / D) * (sin(theta) - tan(beta) * cos(theta) * sin(phi) -\n                         tan(alpha) * cos(theta) * cos(phi)) +\n             w_p + L * theta_dot * cos(theta))\n        return u, v, w\n\n',
                 'transforms - logging': "        t_ref_s = 0\n        if t_ref:\n            t_ref_s = egads.algorithms.transforms.IsotimeToSeconds().run([t_ref], '19500101T000000')\n        t_s = t + egads.EgadsData(value=t_ref_s, units='s').rescale('year').value\n        t_y = t_s + 1950\n        return t_y\n",
                 'microphysics - extinction_coeff_dmt': '        S = numpy.pi * numpy.sum(s_i * n_i * d_i ** 2, axis=1) # um^2/cm^3\n        return S\n',
                 'microphysics - SampleVolumeGeneralRaf': '        SA = numpy.array(SA)\n        if SA.ndim == 0:\n            SV = V_t * SA * t_s\n        else:\n            SV = numpy.zeros([len(V_t), len(SA)])\n            for i, SA_bin in enumerate(SA):\n                SV[:, i] = V_t * SA_bin * t_s\n        return SV\n    ',
                 'radiation - rotate_solar_vector_to_aircraft_frame': '        h = 6.62606957e-34  # J s\n        kb = 1.3806e-23\n        c = 2.997925e8\n        l = Lambda * 1e-9\n        rad = rad * 1e9\n        T = h * c / (kb * l * numpy.log(2 * h * c ** 2 / (l ** 5 * rad) + 1))\n        return T\n\n',
                 'microphysics - MassConcDmt': '        d_i = d_i * 1.0e-4\n        if c_i.ndim <= 1:\n            M = (numpy.pi / 6.0) * numpy.sum(s_i * rho_i * c_i * d_i ** 3)\n        else:\n            M = (numpy.pi / 6.0) * numpy.sum(s_i * rho_i * c_i * d_i ** 3, axis=1)\n        return M\n\n'}
    return info_dict
